# 4. Setup wildcard dns resolution

A k8s cluster uses proxy/reverse-proxy (e.g. ingress-nginx) to expose the hosted service with an url. Thus having a dns server that can resolve the specific domain name and send query to the nodes that host the proxy/reverse-proxy is essentail for a k8s cluster.

For k8s in public cloud, you can use the dns server offered by the cloud. But in our case, we need to install a dns server by ourselves.

For now, we choose **DNSMasq** as our local DNS server for local name resolution

## 4.1 Understanding the dns name reolution Process

When you type an [URL](https://en.wikipedia.org/wiki/URL) in your web browser, the web browser will first use the DNS protocol to contact the DNS server that has been configured in your web brower (or PC).

The DNS server will respond to the resolution request with the IP address of the server that host the website or return a not found message.

Once the browser has the IP address of the website it can connect to it. If the DNS process fails you get a server not found displayed in the browser.

This process is the same for all applications (e.g. email, Skype etc) that use `URL`. They all rely on DNS working in the background to map URL to an IP address.

## 4.2 Tools for url testing

For linux, the two popular tool for url testing is **nslookup** and **dig**.

You can find a complete tutorial of dig [here](https://linuxize.com/post/how-to-use-dig-command-to-query-dns-in-linux/)

```shell

nslookup <url> <dns-server-IP>

dig <url> @<dns-server-IP>

# example 
nslookup google.fr 8.8.8.8
dig google.fr @8.8.8.8
```

If you don't specify the dns-server-ip, they will use the dns server defined in `/etc/resolv.conf`. Note you way find multi dns server in this file. The server on top will be used first, so order matters in this file.

## 4.3 Install DNSMasq

### Disable systemd-resolve

For recent release of debian and ubuntu, it may already have a service `systemd-resolve` that binds to port 53. You need to disable it, otherwise it will cause conflict with `DNSMasq`.

```shell
# check status
sudo systemctl status systemd-resolved

# remove it from boot start service list
sudo systemctl disable systemd-resolved

# stop the service
sudo systemctl stop systemd-resolved

# for some ubuntu version, you need to check also the /etc/resolv.conf
ls -lh /etc/resolv.conf 
lrwxrwxrwx 1 root root 39 Aug  8 15:52 /etc/resolv.conf -> ../run/systemd/resolve/stub-resolv.conf

# if you see there is a symlink, you need to remove the link
sudo unlink /etc/resolv.conf

# then create a new, 8.8.8.8 is the default IP of the dns server of google
echo nameserver 8.8.8.8 | sudo tee /etc/resolv.conf
```

### Install and configure dnsmasq package

**Suppose your dnsmasq will be installed on server 10.50.5.55 **
Dnsmasq is available on the apt repository, easy installation can be done by running:

```shell
sudo apt update

sudo apt install dnsmasq

```

The main configuration file for Dnsmasq is **/etc/dnsmasq.conf**. Configure Dnsmasq by modifying this file.

Below is an example of minimun setup of a dns server

```text
# Setup the specific port (the standard DNS port is 53). Setting this to zero completely 
# disables DNS function, leaving only DHCP and/or TFTP.

port=53

# Enable checks on the income query domain name, if the name is not valid
# Never forward the unvalid names (without a dot or domain part)

domain-needed

# Never forward addresses in the non-routed address spaces.
bogus-priv

# Setup a dns server resolver list file, if not set, the default path /etc/resolv.conf will be used, 
# dnsmasq will send queries to any of the upstream servers it knows about and tries to favour servers to # are known to be up. 

resolv-file=/etc/dnsmasq-dns.conf

# This forces dnsmasq to try each query with each server strictly in the order they appear in the file

strict-order

# add a mapping file of host url and ip address, the default one is /etc/hosts
# note this will not support wildcard. It means if a 10.0.2.10 casd.fake is set. The dnsmasq 
# will not resolv toto.casd.fake, it can only resolv casd.fake   
addn-hosts=/etc/dnsmasq-hosts.conf

# Set this (and domain: see below) if you want to have a domain
# automatically added to simple names in a hosts-file.
expand-hosts

# Set the domain for dnsmasq. this is optional, but if it is set, it
# does the following things.
# 1) Allows DHCP hosts to have fully qualified domain names, as long
#     as the domain part matches this setting.
# 2) Sets the "domain" DHCP option thereby potentially setting the
#    domain of all systems configured by DHCP
# 3) Provides the domain part for "expand-hosts"

domain=casd.test


# wild card rules, it means all url like *.casd.local will be translate to 10.50.5.59
address=/casd.local/10.50.5.59


# enable dns log, the default log path is /var/log/messages
log-queries
```

Because we don't use the defautl resolv and hosts config file, so we need to create our own.

Below is an example of dnsmasq-dns.conf (=/etc/resolv.conf)

```text
# note the order is important
nameserver 8.8.8.8
# the ip of the dnsmasq host
nameserver 10.50.5.55
```

Below is an example of dnsmasq-hosts.conf (=/etc/hosts)

```text
# note below rules are not wildcard
127.0.0.1 localhost
10.50.5.59 datalab.casd.test
```

You need to restart the service

```shell

sudo systemctl restart dnsmasq 

# you can also add it in start list
sudo systemctl enable dnsmasq  
```

### Test the wildcard resolution

If you are testing the dns on another server, you need to setup dns address of the server to 10.50.5.55(the server that dnsmasq is running)

```shell
# install dig
sudo apt install dnsutils

# test if your dns is setup correctlly
dig toto.datalab.casd.local

# You should see below output
# <<>> DiG 9.16.33-Debian <<>> toto.datalab.casd.local
# ;; global options: +cmd
# ;; Got answer:

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;toto.datalab.casd.local.       IN      A

;; ANSWER SECTION:
toto.datalab.casd.local. 0      IN      A       10.50.5.59

;; Query time: 0 msec
;; SERVER: 10.50.5.58#53(10.50.5.58)
;; WHEN: Tue Sep 27 10:37:18 CEST 2022
;; MSG SIZE  rcvd: 68


# if not you can specify the dns server address
dig toto.datalab.casd.local @10.50.5.55
```

### Config client server to use the dns server

In debian/ubuntu, there are two ways to specify which dns server the network device will use
- **/etc/resolv.conf**
- **/etc/network/interfaces**

#### resolv.conf

Below is an example of resolv.conf

```shell
search casd.local
nameserver 10.50.5.58
nameserver 8.8.8.8
```

The order is important here, the search will be in order.

#### interfaces

Below is an example.
```shell
iface eth0 inet static
	address 10.50.5.103/24
	gateway 10.50.0.1
	dns-nameservers 10.50.5.58 8.8.8.8
```


### Setup k8s cluster dns

The official doc for [dns debugging](https://kubernetes.io/docs/tasks/administer-cluster/dns-debugging-resolution/)

There are two kinds of services in k8s cluster to manage dns resolution. 


- coredns ([official doc](https://kubernetes.io/docs/tasks/administer-cluster/coredns/)): This pod runs a k8s cluster dns
- nodelocaldns ([official doc](https://kubernetes.io/docs/tasks/administer-cluster/nodelocaldns/)): This pod runs a dns caching agent on each node of the k8s cluster to reduce dns resolution time. It will query coredns (or kube-dns) service for cache misses of cluster hostnames periodically.  


Note `coredns` is the default dns server to replace the the old `kube-dns`.

The coredns will use the host dns setting (/etc/resolv.conf) as its dns setting.

#### Solution 1: Modify host /etc/resolv.conf

After modifying the host `/etc/resolv.conf`, you need to restart all pods of `coredns` and `nodelocaldns`

#### Solution 2: Modify kubelet config

In each node, kubelete also has a `config file(/var/lib/kubelet/config.yaml)` that allows you to configure cluster dns.

You can find below yaml as an example. In it we set `169.254.25.10` as an example

```yaml
apiVersion: kubelet.config.k8s.io/v1beta1
authentication:
  anonymous:
    enabled: false
  webhook:
    cacheTTL: 0s
    enabled: true
  x509:
    clientCAFile: /etc/kubernetes/ssl/ca.crt
authorization:
  mode: Webhook
  webhook:
    cacheAuthorizedTTL: 0s
    cacheUnauthorizedTTL: 0s
cgroupDriver: systemd
clusterDNS:
- 169.254.25.10
clusterDomain: cluster.local
cpuManagerReconcilePeriod: 0s
evictionPressureTransitionPeriod: 0s
fileCheckFrequency: 0s
healthzBindAddress: 127.0.0.1
healthzPort: 10248
httpCheckFrequency: 0s
imageMinimumGCAge: 0s
kind: KubeletConfiguration
logging:
  flushFrequency: 0
  options:
    json:
      infoBufferSize: "0"
  verbosity: 0
memorySwap: {}
nodeStatusReportFrequency: 0s
nodeStatusUpdateFrequency: 0s
rotateCertificates: true
runtimeRequestTimeout: 0s
shutdownGracePeriod: 0s
shutdownGracePeriodCriticalPods: 0s
staticPodPath: /etc/kubernetes/manifests
streamingConnectionIdleTimeout: 0s
syncFrequency: 0s
volumeStatsAggPeriod: 0s

```

After modifying the `/var/lib/kubelet/config.yaml`, you need to restart all pods of `coredns` and `nodelocaldns`