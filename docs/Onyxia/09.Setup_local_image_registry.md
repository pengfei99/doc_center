# Setup local image registry

As the onyxia instance inside CASD secure bubble does not have internet connextion, so it can't use `docker hub` to pull the image. So CASD need to have its own local container image registry.

After comparing docker registry and harbor, we choose harbor as our solution.

## Harbor install and config

To install and config harbor, please read this [Harbor_standalone_installation.md](./image_registry/05.Harbor_standalone_installation.md)

## Configure k8s to use harbor as image registry

There are a few challenges to be able to use a local image registry
- TLS config: If you are useing a self-signed certificate to secure your local image registry, you need to make your k8s cluster container runtime to accept this certificate.
- registry authentication: If your local registry requires authentication, you need to create a secret, then call it whenever you need to pull image from this registry



### Add self signed certificate to the containerd runtime

The best way to do this is to setup a daemonset which will `install and config the provided CA file on each worker node that runs containerd`.

The complete daemonset config contains three part
1. configmap of the CA certificate
2. configmap of the shell command to copy/config certificate, and restart containerd daemon
3. A daemonset that reads the above configmap and run the shell command.

Some ponits which need to be mentioned:
- The daemonset uses a privileged security context and hostPID in order to be able to execute commands on the nodes. The `privileged commands are run in an initContainers`, then `an un-privileged container` is left running.
- The shell commands is stored in a ConfigMap so they can be modified independantly of the DaemonSet.
- The daemonset uses a vanilla base image (Debian). You can use any image that has the `nsenter tool ` installed (also tested with Alpine). No need to build a custom image.
- We don't want to modify the containerd configuration on the host server. Because if you are using a hosted Kubernetes cluster, like GKS, or Azure Kubernetes Service (AKS), you may not have the privilege to do so. Instead, add custom CA certificate as trusted CA has minimun impact and require less privilege.
- For now, the [containerd](https://github.com/containerd/containerd) restart is mandatory. It may change for future release.

#### First configMap that stores the CA certificate 

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: trusted-ca
  namespace: kube-system
data:
  ca.crt: |+
    -----BEGIN CERTIFICATE-----
    MIICGDCCAb6gAwIBAgIUEBGTVbGL5johNO8jXwYeCI5SH7cwCgYIKoZIzj0EAwIw
    WDELMAkGA1UEBhMCRlIxETAPBgNVBAcTCE1hbGFrb2ZmMRswGQYDVQQKExJDQVNE
    IFRydXN0IFNlcnZpY2UxGTAXBgNVBAMTEENBU0QgazhzIFJPT1QgQ0EwHhcNMjIx
    MDEyMDcyMDAwWhcNMjcxMDExMDcyMDAwWjBYMQswCQYDVQQGEwJGUjERMA8GA1UE
    BxMITWFsYWtvZmYxGzAZBgNVBAoTEkNBU0QgVHJ1c3QgU2VydmljZTEZMBcGA1UE
    AxMQQ0FTRCBrOHMgUk9PVCBDQTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABEVz
    2wmHEdIIpAYm3dSg/p8PThC3cASDrbsX0qTpcAEeU8JYtkxhhT1WQJp5XMlD2YDe
    zCWq2xrcw2sjofcRQ1ujZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMBAf8ECDAG
    AQH/AgECMB0GA1UdDgQWBBSPMq1t72FePGfHaSWG66FAirMADDAfBgNVHSMEGDAW
    gBSPMq1t72FePGfHaSWG66FAirMADDAKBggqhkjOPQQDAgNIADBFAiAVnUzppLzH
    IICTW127nI/RgU2Us9FZKAWNzZa7PiseKQIhALu+UcPN1KXL4EfuLsgZFOcmPMBH
    m6gYOKog2jghWFSz
    -----END CERTIFICATE-----
```

#### Second configMap that stores the shell command
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: setup-script
  namespace: kube-system
data:
  setup.sh: |
    echo "$TRUSTED_CERT" > /usr/local/share/ca-certificates/ca.crt && update-ca-certificates && systemctl restart containerd

```

#### DaemonSet spec

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  namespace: kube-system
  name: custom-ca-manager
  labels:
    k8s-app: custom-ca-manager
spec:
  selector:
    matchLabels:
      k8s-app: custom-ca-manager
  template:
    metadata:
      labels:
        k8s-app: custom-ca-manager
    spec:
      hostPID: true
      hostNetwork: true
      initContainers:
      - name: init-node
        command: ["nsenter"]
        args: ["--mount=/proc/1/ns/mnt", "--", "sh", "-c", "$(SETUP_SCRIPT)"]
        image: debian
        env:
        - name: TRUSTED_CERT
          valueFrom:
            configMapKeyRef:
              name: trusted-ca
              key: ca.crt
        - name: SETUP_SCRIPT
          valueFrom:
            configMapKeyRef:
              name: setup-script
              key: setup.sh
        securityContext:
          privileged: true
      containers:
      - name: wait
        image: k8s.gcr.io/pause:3.1
```

You can put the above three parts into one file. You can find the example [here](../resources/k8s_certi/daemonset_containerd.yaml)


## Use Harbor to replicate images from other image registry

Replication allows users to replicate images, between Harbor and non-Harbor registries, in both pull or push mode.

- In pull mode, harbor will pull(download) images from remote image registry (e.g. dockerhub). 
- In push mode, when you push an image to harbor, harbor will push it to a remote registry.

### Step 1. Create a replication endpoint


### Step 2. Create a replication rule

For official image which does not have library before image name, you need to put the `source resource filter` as  **library/redis instead of redis**. For images that are located inside a library, you just use the origin name, for example for image **inseefrlab/atlas**, the source resource filter is **inseefrlab/atlas**.

### Step 3. Running a replication task


